<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vehicle Status Dashboard</title>
    
    <style>
/* Warm green palette */
:root {
	--primary-color: #4CAF50;
	--text-color: #ff7777;
	--text-secondary-color: #388E3C; 

	--bg-color: #222222;
	--panel-bg: #000000;
	--border-color: #00ff00;
}

body {
	font-family: sans-serif; /* Changed to a generic sans-serif font */
	background-color: var(--bg-color);
	display: flex;
	flex-wrap: wrap; /* Allow multiple widgets to wrap */
	gap: 20px; /* Space between widgets */
	padding: 20px;
	justify-content: center; /* Center widgets horizontally */
	align-items: flex-start; /* Align widgets to the top */
	min-height: 100vh; /* Ensure body takes full viewport height */
	margin: 0;
	box-sizing: border-box;
}

/* Container for all widgets */
#container {
	display: flex;
	flex-wrap: wrap;
	gap: 20px;
	justify-content: center;
	width: 100%; /* Take full width of parent (body) */
}

/* Generic Dash Panel Style */
.dash-panel {
	background-color: var(--panel-bg);
	border: 1px solid var(--border-color);
	border-radius: 12px;
	box-shadow: 15px 15px 15px rgb(0, 0, 0);
	padding: 20px;
	box-sizing: border-box;
	display: flex;
	flex-direction: column;
	overflow: hidden;
	transition: transform 0.2s ease-in-out;
}

.dash-panel:hover {
	transform: translateY(-5px); /* Lift effect on hover */
}

.widget-header {
	margin-bottom: 15px;
	padding-bottom: 10px;
	border-bottom: 1px solid var(--border-color);
}

.widget-title {
	font-size: 1.4em;
	color: var(--text-secondary-color);
	margin: 0;
	text-align: center;
	font-weight: 600;
}

.widget-content {
	flex-grow: 1; /* Allows content to take available space */
}

.metric {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 8px 0;
	border-bottom: 1px dashed var(--border-color);
}

.metric:last-of-type {
	border-bottom: none; /* No border for the last metric */
}

.label {
	font-size: 1em;
	color: var(--text-color);
	font-weight: 500;
}

.value {
	font-size: 1.1em;
	color: var(--primary-color);
	font-weight: 700;
}

.progress-bar-container {
	background-color: #e0e0e0;
	border-radius: 8px;
	height: 15px;
	margin-top: 15px;
	overflow: hidden;
	position: relative;
}

.progress-bar {
	background-color: var(--primary-color);
	height: 100%;
	border-radius: 8px;
	width: 0%; /* Initial width, will be set by JS */
	transition: width 0.5s ease-out; /* Smooth transition for progress */
}

/* Responsive adjustments for widget layout */
@media (min-width: 300px) {
	.dash-panel {
		width: calc(100% - 30px); /* Two columns on medium screens */
	}
}

@media (min-width: 600px) {
	.dash-panel {
		width: calc(66% - 30px); /* Two columns on medium screens */
	}
}

@media (min-width: 900px) {
	.dash-panel {
		width: calc(33.333% - 30px); /* Three columns on larger screens */
	}
}
    </style>
</head>

<body>
</body>

<script>
/******************************************************************************
 * NETWORK
 *****************************************************************************/
class network
{
	#ws; /* Websocket */

	/* If there are no messages for certain period */
	#connection_timeout_ms = 0; /* No timeout */
	#connection_timer;
	
	#is_alive     = false;
	#is_connected = false;

	#listeners = {}; /* Objects that listen network messages */

	/* Prevents connection timeout, when timeout is set */
	#keep_alive()
	{
		clearTimeout(this.#connection_timer);
		this.#is_alive = true;

		this.#connection_timer = setTimeout(() => {
			if (this.#is_alive == true) {
				this.on_timeout();
			}

			this.#is_alive = false;

			this.#ws.close();
		}, this.#connection_timeout_ms);
	}

	#send(id, data)
	{
		console.log(this.constructor.name + '.send: ' + id + ', ' +
								data + ')');

		this.#ws.send(JSON.stringify([ id, data ]));
	};

	#recv(data)
	{
		console.log(this.constructor.name + '.recv: ' + data);
		data = JSON.parse(data);

		/* if it contains single message */
		if (typeof (data[0]) != "object") {
			const listener = this.#listeners[data[0]];

			listener.net.recv.call(listener, data[1]);
		} else {
			/* if it contains multiple messages */
			for (var i = 0; i < data.length; i++) {
				const listener = this.#listeners[data[i][0]];

				listener.net.recv.call(listener, data[i][1]);
			};
		}

		if (this.#connection_timeout_ms > 0) {
			this.#keep_alive();
		}
	}

	/* Global events (can be overriden by user) */
	on_connect()
	{
		console.log(this.constructor.name + '.on_connect')
	};
	
	on_disconnect()
	{
		console.log(this.constructor.name + '.on_disconnect')
	};
	
	on_timeout()
	{
		console.log(this.constructor.name + '.on_timeout')
	};
	
	on_error()
	{
		console.log(this.constructor.name + '.on_error')
	};
	
	on_message(data) {
		console.log(this.constructor.name + '.on_message')
	};

	connect(ip, timeout)
	{
		this.#connection_timeout_ms = timeout;

		this.#ws = new WebSocket('ws://' + ip + '/ws');

		this.#ws.onopen = (evt) =>
		{
			this.#is_connected = true;

			if (this.#connection_timeout_ms > 0) {
				this.#keep_alive();
			}

			this.on_connect();
		};

		this.#ws.onclose = (evt) =>
		{
			if (this.#is_connected == true) {
				this.#is_connected = false;
				this.on_disconnect();
			}

			/* Destroy websocket */
			this.#ws = null;

			this.connect(ip, timeout);
		};

		this.#ws.onerror = (evt) =>
		{
			if (this.#is_connected == true) {
				this.on_error();
			}
		};
		
		this.#ws.onmessage = (evt) =>
		{
			this.on_message(evt.data)
			this.#recv(evt.data);
		};
	}

	/* Add message listener to object */
	add_listener(object)
	{
		const base = this;

		this.#listeners[object.id] = object;
		object.net = {};

		/* Can be overriden by user */
		object.net.recv = function(data) {
			console.log(this.id + '.dataset.net.recv: ' + data);
		};

		/* Shall NOT be overriden by user */
		object.net.send = function(data) {
			base.#send(object.id, data);
		};
	};

	constructor(ip, timeout)
	{
		this.connect(ip, timeout);
	}
}

/******************************************************************************
 * WIDGETS
 *****************************************************************************/
/**
  * Helper function to create an HTML element.
  * @param {string} tagName - The tag name of the element (e.g., 'div', 'span', 'h3').
  * @param {string} [className=''] - Optional CSS class name(s) for the element.
  * @param {string} [textContent=''] - Optional text content for the element.
  * @param {object} [attributes={}] - Optional object of attributes to set (e.g., { 'data-metric': 'voltage' }).
  * @returns {HTMLElement} The created HTML element.
  */
function createElement(tagName, className = '', textContent = '', attributes = {}) {
	const element = document.createElement(tagName);
	if (className) {
		element.className = className;
	}
	if (textContent) {
		element.textContent = textContent;
	}
	for (const key in attributes) {
		if (attributes.hasOwnProperty(key)) {
			element.setAttribute(key, attributes[key]);
		}
	}
	return element;
}

// Helper to create a metric row
function createMetricRow(parent, labelText, metricName, initialValue)
{
	const metricDiv = createElement('div', 'metric');
	const labelSpan = createElement('span', 'label', labelText);
	const valueSpan = createElement('span', 'value', initialValue, { 'data-metric': metricName });
	metricDiv.appendChild(labelSpan);
	metricDiv.appendChild(valueSpan);
	parent.appendChild(metricDiv);
	return valueSpan; // Return the value span for later updates
};

/******************************************************************************
 * MAIN
 *****************************************************************************/
const WEB_MSG_CPU_RESET  = 0;
const WEB_MSG_VEH_STATUS = 1;

network = new network("10.10.10.10", 10000);

class VehicleStatusWidget {
	constructor(containerId, id, title = 'Vehicle Status') {
		this.id = id;
		this.title = title;
		// Get the container element, default to document.body if not found
		this.container = document.getElementById(containerId) || document.body;
		this.element = null; // Holds the main widget div element
		this.metricElements = {}; // Stores references to specific HTML elements for quick updates

		this._createWidget();
	}

	_createWidget() {
		// Main widget container
		this.element = createElement('div', 'dash-panel');
		this.element.id = `widget-${this.id}`;

		// Widget Header
		const header = createElement('div', 'widget-header');
		const titleElement = createElement('h3', 'widget-title', this.title);
		header.appendChild(titleElement);
		this.element.appendChild(header);

		// Widget Content
		const content = createElement('div', 'widget-content');

		// Create metric rows and store references
		this.metricElements.voltage = createMetricRow(content, 'Voltage:', 'voltage', '-- V');
		this.metricElements.current = createMetricRow(content, 'Current:', 'current', '-- A');
		this.metricElements.capacity = createMetricRow(content,'Capacity:', 'capacity', '-- / -- Ah');
		this.metricElements.soc = createMetricRow(content, 'SOC:', 'soc', '--%');

		// Progress Bar for SOC
		const progressBarContainer = createElement('div', 'progress-bar-container');
		this.metricElements.socProgress = createElement('div', 'progress-bar', '', { 'data-metric': 'soc-progress' });
		progressBarContainer.appendChild(this.metricElements.socProgress);
		content.appendChild(progressBarContainer);

		this.element.appendChild(content);

		// Append the newly created widget element to the specified container
		this.container.appendChild(this.element);
	}

	update(data) {
		// Ensure the widget element has been created before attempting to update
		if (!this.element) {
			console.error(`Widget with ID '${this.id}' has not been initialized.`);
			return;
		}

		// Update voltage if provided
		if (data.voltage !== undefined) {
			this.metricElements.voltage.textContent = `${data.voltage.toFixed(1)} V`;
		}
		// Update current if provided
		if (data.current !== undefined) {
			this.metricElements.current.textContent = `${data.current.toFixed(1)} A`;
		}
		// Update capacity if both current and full capacity are provided
		if (data.capacity !== undefined && data.fullCapacity !== undefined) {
			this.metricElements.capacity.textContent = `${data.capacity.toFixed(1)} / ${data.fullCapacity.toFixed(1)} Ah`;
		}
		// Update State of Charge (SOC) and its progress bar if provided
		if (data.soc !== undefined) {
			// Clamp SOC value between 0 and 100 to prevent visual issues
			const socValue = Math.max(0, Math.min(100, data.soc));
			this.metricElements.soc.textContent = `${socValue.toFixed(0)}%`;
			this.metricElements.socProgress.style.width = `${socValue}%`;
		}
	}
}

// Create multiple instances of the VehicleStatusWidget
const mainVehicleWidget = new VehicleStatusWidget(null, 'mainVehicle', 'Main Battery');

// --- Simulate real-time data updates ---
// Initial data for each widget
let data1 = { voltage: 12.5, current: -5.0, capacity: 50, fullCapacity: 100, soc: 50 };

// Update widgets with initial data
mainVehicleWidget.update(data1);

</script>
</html>
